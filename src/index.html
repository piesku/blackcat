<!DOCTYPE html>
<meta charset="utf8" />
<meta name="viewport" content="width=device-width, user-scalable=0" />
<title>BlackCat</title>
<link rel="stylesheet" href="../play/game.css" />
<link rel="stylesheet" href="../play/debug.css" />
<body>
    <!-- Add it to play/game.html too. -->
    <img hidden src="../sprites/atlas.png.webp" />
    <canvas id="background"></canvas>
    <canvas id="scene"></canvas>
    <canvas id="foreground"></canvas>
    <main></main>

    <div id="debug">
        <span>update: <span id="update"></span></span>
        <span>fps: <span id="fps"></span></span>
        <span><button onclick="toggle(this)">pause</button></span>
        <span><button onclick="toggleSceneGraph(this)">scene graph</button></span>
    </div>

    <!-- Scene Graph Inspector -->
    <div id="scene-graph" style="display: none;">
        <div id="scene-graph-header">
            <h3>Scene Graph Inspector</h3>
            <div class="header-buttons">
                <button onclick="refreshSceneGraph()">Refresh</button>
                <button onclick="toggleSceneGraph()">Close</button>
            </div>
        </div>
        <div id="scene-graph-content">
            <div id="entity-list"></div>
            <div id="entity-details"></div>
        </div>
    </div>
    <script type="module">
        import "./index.js";

        window.toggle = function toggle(button) {
            if (game.IsRunning) {
                game.Stop();
                button.textContent = "resume";
            } else {
                game.Start();
                button.textContent = "pause";
            }
        };

        window.toggleSceneGraph = function toggleSceneGraph() {
            const panel = document.getElementById('scene-graph');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
                refreshSceneGraph();
            } else {
                panel.style.display = 'none';
            }
        };

        function updateSceneGraphHeader() {
            if (!window.game) return;
            
            const world = game.World;
            let activeCount = 0;
            for (let entity = 0; entity < world.Signature.length; entity++) {
                if (world.Signature[entity] !== 0) activeCount++;
            }
            
            const header = document.querySelector('#scene-graph-header h3');
            if (header) {
                header.textContent = `Scene Graph (${activeCount} entities)`;
            }
        }

        window.refreshSceneGraph = function refreshSceneGraph() {
            if (!window.game) return;
            
            // Update header with entity count
            updateSceneGraphHeader();
            
            const entityList = document.getElementById('entity-list');
            const world = game.World;
            
            let html = '<div class="entity-tree">';
            
            // Build tree hierarchy
            const hierarchy = buildEntityHierarchy(world);
            html += renderEntityTree(hierarchy, 0);
            
            html += '</div>';
            entityList.innerHTML = html;
        };

        function buildEntityHierarchy(world) {
            // Find all root entities (no parent or parent doesn't exist)
            const roots = [];
            const childrenMap = new Map();
            
            // First pass: collect all entities and their children
            for (let entity = 0; entity < world.Signature.length; entity++) {
                if (world.Signature[entity] === 0) continue; // Skip dead entities
                
                const spatialNode = world.SpatialNode2D[entity];
                if (spatialNode) {
                    // Entity has spatial node - check parent relationship
                    if (spatialNode.Parent !== undefined && world.Signature[spatialNode.Parent] !== 0) {
                        // Has valid parent - add to parent's children
                        if (!childrenMap.has(spatialNode.Parent)) {
                            childrenMap.set(spatialNode.Parent, []);
                        }
                        childrenMap.get(spatialNode.Parent).push(entity);
                    } else {
                        // No parent or invalid parent - is root
                        roots.push(entity);
                    }
                } else {
                    // No spatial node - treat as root entity
                    roots.push(entity);
                }
            }
            
            // Build tree structure recursively
            function buildNode(entityId) {
                const children = childrenMap.get(entityId) || [];
                return {
                    id: entityId,
                    children: children.map(childId => buildNode(childId))
                };
            }
            
            return roots.map(rootId => buildNode(rootId));
        }

        function renderEntityTree(nodes, depth) {
            let html = '';
            
            for (const node of nodes) {
                const entity = node.id;
                const components = getEntityComponents(entity);
                const name = getEntityName(entity) || `Entity ${entity}`;
                const hasChildren = node.children.length > 0;
                
                // Indentation for tree structure
                const indent = '  '.repeat(depth);
                const expandIcon = hasChildren ? 
                    `<span class="tree-toggle" onclick="toggleTreeNode(this, event)">▼</span>` : 
                    `<span class="tree-spacer">•</span>`;
                
                // Format name line: either "named_entity" or "entity N" 
                const entityName = getEntityName(entity);
                const displayName = entityName ? entityName : `entity ${entity}`;
                
                html += `<div class="tree-node" style="margin-left: ${depth * 20}px;">
                    <div class="entity-item" onclick="selectEntity(${entity})">
                        <div class="entity-header">
                            ${expandIcon}
                            <strong>${displayName}</strong>
                            <span class="entity-id">id: ${entity}</span>
                        </div>
                        <small>${components.join(', ')}</small>
                    </div>
                    <div class="tree-children">
                        ${renderEntityTree(node.children, depth + 1)}
                    </div>
                </div>`;
            }
            
            return html;
        }

        window.toggleTreeNode = function toggleTreeNode(toggleElement, event) {
            event.stopPropagation(); // Prevent entity selection
            
            const treeNode = toggleElement.closest('.tree-node');
            const childrenDiv = treeNode.querySelector('.tree-children');
            
            if (childrenDiv.style.display === 'none') {
                childrenDiv.style.display = 'block';
                toggleElement.textContent = '▼';
            } else {
                childrenDiv.style.display = 'none';
                toggleElement.textContent = '▶';
            }
        };

        window.selectEntity = function selectEntity(entityId) {
            const details = document.getElementById('entity-details');
            const world = game.World;
            
            if (world.Signature[entityId] === 0) {
                details.innerHTML = '<h4>Entity not found</h4>';
                return;
            }
            
            const name = getEntityName(entityId) || `Entity ${entityId}`;
            const components = getEntityComponents(entityId);
            
            let html = `<h4>${name} (ID: ${entityId})</h4>`;
            html += `<p><strong>Signature:</strong> ${world.Signature[entityId]} (0b${world.Signature[entityId].toString(2)})</p>`;
            
            html += '<h5>Components:</h5>';
            html += '<div class="component-list">';
            
            // Check each component type
            if (world.LocalTransform2D[entityId]) {
                const t = world.LocalTransform2D[entityId];
                html += `<div class="component">
                    <strong>LocalTransform2D</strong><br>
                    Translation: [${t.Translation[0].toFixed(2)}, ${t.Translation[1].toFixed(2)}]<br>
                    Rotation: ${t.Rotation.toFixed(2)}<br>
                    Scale: [${t.Scale[0].toFixed(2)}, ${t.Scale[1].toFixed(2)}]
                </div>`;
            }
            
            if (world.SpatialNode2D[entityId]) {
                const s = world.SpatialNode2D[entityId];
                const parentName = s.Parent !== undefined ? 
                    (getEntityName(s.Parent) || `Entity ${s.Parent}`) : 'None';
                const childrenNames = s.Children ? 
                    s.Children.map(id => getEntityName(id) || `Entity ${id}`).slice(0, 3) : [];
                
                html += `<div class="component">
                    <strong>SpatialNode2D</strong><br>
                    Parent: ${parentName}<br>
                    Children: ${s.Children ? s.Children.length : 0}`;
                
                if (childrenNames.length > 0) {
                    html += `<br><small>└─ ${childrenNames.join(', ')}${s.Children && s.Children.length > 3 ? '...' : ''}</small>`;
                }
                
                html += `</div>`;
            }
            
            if (world.Render2D[entityId]) {
                const r = world.Render2D[entityId];
                html += `<div class="component">
                    <strong>Render2D</strong><br>
                    Sprite: ${r.Sprite}<br>
                    Color: [${r.Color[0].toFixed(2)}, ${r.Color[1].toFixed(2)}, ${r.Color[2].toFixed(2)}, ${r.Color[3].toFixed(2)}]
                </div>`;
            }
            
            if (world.Health[entityId]) {
                const h = world.Health[entityId];
                html += `<div class="component">
                    <strong>Health</strong><br>
                    Current: ${h.Current} / ${h.Max}<br>
                    Alive: ${h.IsAlive}<br>
                    Pending Damage: ${h.PendingDamage ? h.PendingDamage.length : 0}
                </div>`;
            }
            
            if (world.AIFighter[entityId]) {
                const ai = world.AIFighter[entityId];
                html += `<div class="component">
                    <strong>AIFighter</strong><br>
                    State: ${ai.State}<br>
                    Target: ${ai.Target}<br>
                    Aggressiveness: ${ai.Aggressiveness.toFixed(2)}<br>
                    Patience: ${ai.Patience.toFixed(2)}
                </div>`;
            }
            
            if (world.Move2D[entityId]) {
                const m = world.Move2D[entityId];
                html += `<div class="component">
                    <strong>Move2D</strong><br>
                    Direction: [${m.Direction[0].toFixed(2)}, ${m.Direction[1].toFixed(2)}]<br>
                    Speed: ${m.MoveSpeed}<br>
                    Rotation Speed: ${m.RotationSpeed}
                </div>`;
            }
            
            if (world.RigidBody2D[entityId]) {
                const rb = world.RigidBody2D[entityId];
                html += `<div class="component">
                    <strong>RigidBody2D</strong><br>
                    Kind: ${rb.Kind}<br>
                    Velocity: [${rb.VelocityLinear[0].toFixed(2)}, ${rb.VelocityLinear[1].toFixed(2)}]<br>
                    Gravity: [${rb.Gravity[0].toFixed(2)}, ${rb.Gravity[1].toFixed(2)}]<br>
                    Drag: ${rb.Drag.toFixed(2)}
                </div>`;
            }
            
            if (world.Collide2D[entityId]) {
                const c = world.Collide2D[entityId];
                html += `<div class="component">
                    <strong>Collide2D</strong><br>
                    Layer: ${c.Layer}<br>
                    Mask: ${c.Mask}<br>
                    Radius: ${c.Radius.toFixed(2)}<br>
                    Collisions: ${c.Collisions.length}
                </div>`;
            }
            
            if (world.Weapon[entityId]) {
                const w = world.Weapon[entityId];
                html += `<div class="component">
                    <strong>Weapon</strong><br>
                    Kind: ${w.Kind}<br>
                    Damage: ${w.Damage}<br>
                    Range: ${w.Range}<br>
                    Cooldown: ${w.Cooldown.toFixed(2)}<br>
                    Last Attack: ${w.LastAttackTime.toFixed(2)}
                </div>`;
            }
            
            if (world.Named[entityId]) {
                const n = world.Named[entityId];
                html += `<div class="component">
                    <strong>Named</strong><br>
                    Name: "${n.Name}"
                </div>`;
            }
            
            html += '</div>';
            details.innerHTML = html;
        };

        function getEntityComponents(entityId) {
            if (!window.game) return [];
            
            const world = game.World;
            const components = [];
            
            if (world.LocalTransform2D[entityId]) components.push('Transform');
            if (world.SpatialNode2D[entityId]) components.push('SpatialNode');
            if (world.Render2D[entityId]) components.push('Render');
            if (world.Health[entityId]) components.push('Health');
            if (world.AIFighter[entityId]) components.push('AI');
            if (world.Move2D[entityId]) components.push('Move');
            if (world.RigidBody2D[entityId]) components.push('RigidBody');
            if (world.Collide2D[entityId]) components.push('Collide');
            if (world.Weapon[entityId]) components.push('Weapon');
            if (world.Named[entityId]) components.push('Named');
            if (world.Spawn[entityId]) components.push('Spawn');
            if (world.Lifespan[entityId]) components.push('Lifespan');
            if (world.DealDamage[entityId]) components.push('DealDamage');
            if (world.Particle[entityId]) components.push('Particle');
            
            return components;
        }

        function getEntityName(entityId) {
            if (!window.game) return null;
            
            const world = game.World;
            if (world.Named[entityId]) {
                return world.Named[entityId].Name;
            }
            
            // Try to infer name from components
            if (world.AIFighter[entityId]) {
                return world.Health[entityId] ? 'Fighter' : 'AI Entity';
            }
            if (world.Weapon[entityId]) {
                return 'Weapon';
            }
            if (world.Particle[entityId]) {
                return 'Particle';
            }
            if (world.Spawn[entityId]) {
                return 'Spawner';
            }
            
            return null;
        }
    </script>
</body>
